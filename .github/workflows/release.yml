name: Release Automation

on:
    pull_request:
        types: [closed]

jobs:
    build-release:
        if: github.event.pull_request.merged == true && startsWith(github.event.pull_request.base.ref, 'release/')
        strategy:
            matrix:
                os: [ubuntu-latest]
                include:
                    - os: ubuntu-latest
                      target: x86_64-unknown-linux-gnu
                      suffix: linux-x64
                      extension: ''
        runs-on: ubuntu-latest
        outputs:
            git-hash: ${{ steps.git-info.outputs.git-hash }}
            git-message: ${{ steps.git-info.outputs.git-message }}
        steps:
            - name: ðŸ“¥ Checkout repository
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0
                  token: ${{ secrets.GITHUB_TOKEN }}

            - name: ðŸ¦€ Setup Rust
              run: |
                  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
                  if [ "$RUNNER_OS" != "Windows" ]; then
                    source ~/.cargo/env
                  fi
                  rustup target add ${{ matrix.target }}
              shell: bash

            - name: ðŸ”§ Install Typst for documentation
              run: |
                  curl -fsSL https://github.com/typst/typst/releases/latest/download/typst-x86_64-unknown-linux-musl.tar.xz | tar -xJ
                  sudo mv typst-x86_64-unknown-linux-musl/typst /usr/local/bin/
              shell: bash

            - name: ðŸ—ï¸ Build release binary
              run: |
                  cargo build --release --target ${{ matrix.target }}
              shell: bash

            - name: ðŸ³ Build Docker image
              run: |
                  VERSION="${{ github.event.pull_request.base.ref }}"
                  VERSION_CLEANED="${VERSION#release/}"
                  docker build -f .github/Dockerfile -t simeis-server:${VERSION_CLEANED} .
              shell: bash

            - name: ðŸ³ Save Docker image as archive
              run: |
                  VERSION="${{ github.event.pull_request.base.ref }}"
                  VERSION_CLEANED="${VERSION#release/}"
                  docker image save simeis-server:${VERSION_CLEANED} -o simeis-server-docker-image.tar
              shell: bash

            - name: ðŸ§ª Test Docker image
              run: |
                  VERSION="${{ github.event.pull_request.base.ref }}"
                  VERSION_CLEANED="${VERSION#release/}"
                  docker run -d --rm -p 8080:8080 --name simeis-server-test simeis-server:${VERSION_CLEANED}
                  sleep 5
                  docker ps | grep simeis-server-test
                  docker stop simeis-server-test
              shell: bash

            - name: ðŸ³ Login to DockerHub
              run: |
                  echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login --username ${{ secrets.DOCKERHUB_USERNAME }} --password-stdin
              shell: bash

            - name: ðŸ³ Tag and push Docker image to DockerHub
              run: |
                  VERSION="${{ github.event.pull_request.base.ref }}"
                  VERSION_CLEANED="${VERSION#release/}"
                  IMAGE_NAME=${{ secrets.DOCKERHUB_USERNAME }}/simeis-server:${VERSION_CLEANED}
                  docker tag simeis-server:${VERSION_CLEANED} $IMAGE_NAME
                  docker push $IMAGE_NAME
              shell: bash

            - name: ðŸ“¤ Upload Docker image artifact
              uses: actions/upload-artifact@v4
              with:
                  name: simeis-server-docker-image
                  path: simeis-server-docker-image.tar
                  retention-days: 1

            - name: ðŸ—ï¸ Build Debian package (.deb)
              run: |
                  VERSION="${{ github.event.pull_request.base.ref }}"
                  VERSION_CLEANED="${VERSION#release/}"
                  mkdir -p mypackage/DEBIAN
                  echo "Package: tev-simeis-server" > mypackage/DEBIAN/control
                  echo "Version: ${VERSION_CLEANED}" >> mypackage/DEBIAN/control
                  echo "Section: base" >> mypackage/DEBIAN/control
                  echo "Priority: optional" >> mypackage/DEBIAN/control
                  echo "Architecture: amd64" >> mypackage/DEBIAN/control
                  echo "Maintainer: Valentin-Droid <valentin@example.com>" >> mypackage/DEBIAN/control
                  echo "Description: Tev Simeis Server Debian Package" >> mypackage/DEBIAN/control
                  mkdir -p mypackage/usr/bin
                  cp target/${{ matrix.target }}/release/simeis-server mypackage/usr/bin/tev-simeis
                  mkdir -p mypackage/usr/lib/systemd/system
                  printf '%s\n' "[Unit]" \
                    "Description=Service Simeis Server TEV" \
                    "After=network.target" \
                    "" \
                    "[Service]" \
                    "Type=simple" \
                    "ExecStart=/usr/bin/tev-simeis" \
                    "Restart=on-failure" \
                    "User=nobody" \
                    "Group=tev" \
                    "" \
                    "[Install]" \
                    "WantedBy=multi-user.target" \
                    > mypackage/usr/lib/systemd/system/simeis.service.tev
                  dpkg-deb --build mypackage "TEV_${VERSION_CLEANED}.deb"
              shell: bash

            - name: ðŸ“‹ Set up Git info for release
              id: git-info
              run: |
                  gitHash=$(git rev-parse --short=8 HEAD)
                  gitMessage=$(git log -1 --pretty=%B)
                  echo "git-hash=$gitHash" >> "$GITHUB_OUTPUT"
                  echo "git-message<<EOF" >> "$GITHUB_OUTPUT"
                  echo "$gitMessage" >> "$GITHUB_OUTPUT"
                  echo "EOF" >> "$GITHUB_OUTPUT"
              shell: bash

            - name: ðŸ“– Generate documentation
              run: |
                  typst compile doc/manual.typ doc/manual.pdf
              shell: bash

            - name: Prepare release artifacts
              run: |
                  mkdir release-artifacts
                  cp target/${{ matrix.target }}/release/simeis-server${{ matrix.extension }} release-artifacts/simeis-server-${{ matrix.suffix }}${{ matrix.extension }}
                  VERSION="${{ github.event.pull_request.base.ref }}"
                  VERSION_CLEANED="${VERSION#release/}"
                  VERSION_CLEANED="${VERSION_CLEANED#V}"
                  if [ -f "TEV_${VERSION_CLEANED}.deb" ]; then cp "TEV_${VERSION_CLEANED}.deb" release-artifacts/TEV_${VERSION_CLEANED}.deb; fi
                  ls -lh release-artifacts
              shell: bash

            - name: ðŸ“¦ Prepare documentation
              run: |
                  mkdir -p release-artifacts
                  cp doc/manual.pdf release-artifacts/simeis-manual.pdf
                  VERSION="${{ github.event.pull_request.base.ref }}"
                  VERSION_CLEANED="${VERSION#release/}"
                  VERSION_CLEANED="${VERSION_CLEANED#V}"
                  tar -czf release-artifacts/simeis-source-${VERSION_CLEANED}.tar.gz \
                    --exclude=target \
                    --exclude=.git \
                    --exclude=build \
                    --exclude=release-artifacts \
                    .
              shell: bash

            - name: ðŸ“¤ Upload release artifacts
              uses: actions/upload-artifact@v4
              with:
                  name: release-artifacts-${{ matrix.suffix }}
                  path: release-artifacts/
                  retention-days: 1

    create_or_update_release:
        if: github.event.pull_request.merged == true && startsWith(github.event.pull_request.base.ref, 'release/')
        needs: build-release
        runs-on: ubuntu-latest
        steps:
            - name: ðŸ“¥ Checkout repository
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0
                  token: ${{ secrets.GITHUB_TOKEN }}

            - name: ðŸ“¥ Download release artifacts
              uses: actions/download-artifact@v4
              with:
                  pattern: release-artifacts-*
                  path: ./artifacts
                  merge-multiple: true

            - name: ðŸ“¥ Download Docker image artifact
              uses: actions/download-artifact@v4
              with:
                  name: simeis-server-docker-image
                  path: ./artifacts

            - name: ðŸ“¦ Consolidate artifacts
              run: |
                  mkdir -p release-artifacts
                  find ./artifacts -name "simeis-server-*" -type f -exec cp {} release-artifacts/ \;
                  find ./artifacts -name "simeis-manual.pdf" -type f -exec cp {} release-artifacts/ \;
                  find ./artifacts -name "simeis-source-*.tar.gz" -type f -exec cp {} release-artifacts/ \;
                  find ./artifacts -name "TEV_*.deb" -type f -exec cp {} release-artifacts/ \;
                  if [ -f ./artifacts/simeis-server-docker-image.tar ]; then cp ./artifacts/simeis-server-docker-image.tar release-artifacts/; fi
                  ls -la release-artifacts/

            - name: ðŸ“ Generate changelog from merged PRs
              id: changelog
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              run: |
                  # Get the latest release tag (if any)
                  latest_tag=$(git tag --sort=-creatordate | grep '^release/' | head -n1)
                  if [ -z "$latest_tag" ]; then
                    base_sha=$(git rev-list --max-parents=0 HEAD)
                  else
                    base_sha=$(git rev-list -n 1 "$latest_tag")
                  fi
                  head_sha=$(git rev-parse HEAD)
                  # Get merged PRs between base_sha and head_sha
                  prs=$(gh pr list --state merged --search "base:$(echo ${{ github.event.pull_request.base.ref }})" --json number,title,headRefName,url,mergedAt --jq '.[] | select(.mergedAt != null) | select(.mergedAt >= ("$(git show -s --format=%cI $base_sha)"))')
                  # Classify PRs
                  features=""
                  bugfixes=""
                  others=""
                  while read -r pr; do
                    pr_number=$(echo "$pr" | jq -r '.number')
                    pr_title=$(echo "$pr" | jq -r '.title')
                    pr_head=$(echo "$pr" | jq -r '.headRefName')
                    pr_url=$(echo "$pr" | jq -r '.url')
                    if [[ "$pr_head" =~ ^feature/ ]]; then
                      features+="- [#$pr_number]($pr_url) $pr_title\n"
                    elif [[ "$pr_head" =~ ^bug/ ]]; then
                      bugfixes+="- [#$pr_number]($pr_url) $pr_title\n"
                    else
                      others+="- [#$pr_number]($pr_url) $pr_title\n"
                    fi
                  done < <(gh pr list --state merged --search "base:$(echo ${{ github.event.pull_request.base.ref }})" --json number,title,headRefName,url,mergedAt --jq '.[] | select(.mergedAt != null) | select(.mergedAt >= ("$(git show -s --format=%cI $base_sha)"))')
                  # Write changelog using proper EOF delimiter
                  {
                    echo "## âœ¨ Features"
                    if [ -n "$features" ]; then echo -e "$features"; else echo "_Aucune_"; fi
                    echo ""
                    echo "## ðŸ› Bugfix"
                    if [ -n "$bugfixes" ]; then echo -e "$bugfixes"; else echo "_Aucun_"; fi
                    echo ""
                    echo "## ðŸ”„ Autre"
                    if [ -n "$others" ]; then echo -e "$others"; else echo "_Aucun_"; fi
                  } > changelog.md
                  # Export for next step using EOF delimiter
                  echo "changelog<<EOF" >> "$GITHUB_OUTPUT"
                  cat changelog.md >> "$GITHUB_OUTPUT"
                  echo "EOF" >> "$GITHUB_OUTPUT"

            - name: Format release name
              id: format_release_name
              run: |
                  NAME="${{ github.event.pull_request.base.ref }}"
                  NAME_CLEANED="${NAME#release/}"
                  echo "name=Release $NAME_CLEANED" >> "$GITHUB_OUTPUT"
                  echo "name_cleaned=$NAME_CLEANED" >> "$GITHUB_OUTPUT"

            - name: Create or update GitHub Release
              uses: mini-bomba/create-github-release@v1.2.0
              with:
                  token: ${{ secrets.GITHUB_TOKEN }}
                  tag: ${{ steps.format_release_name.outputs.name_cleaned }}
                  name: ${{ steps.format_release_name.outputs.name }}
                  body: |
                      Release triggered by @${{ github.actor }}
                      Commit: ${{ needs.build-release.outputs.git-hash }}
                      Message:
                      ${{ needs.build-release.outputs.git-message }}

                      ### Changelog
                      ${{ steps.changelog.outputs.changelog }}

                      - `simeis-server-linux-x64` : Binaire principal optimisÃ© pour Linux x64
                      - `simeis-manual.pdf` : Documentation complÃ¨te du projet
                      - `simeis-source-${{ steps.format_release_name.outputs.name_cleaned }}.tar.gz` : Code source de la release

                      - `TEV_${{ steps.format_release_name.outputs.name_cleaned }}.deb` : Paquet Debian gÃ©nÃ©rÃ© automatiquement (installable avec `sudo apt install ./TEV_${{ steps.format_release_name.outputs.name_cleaned }}.deb`)

                      [Workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
                  files: |
                      release-artifacts/*
                      simeis-server-docker-image.tar
                  clear_attachments: true

    deploy-to-vps:
        name: ðŸš€ Deploy to VPS
        needs: create_or_update_release
        runs-on: ubuntu-latest
        if: github.event.pull_request.merged == true && startsWith(github.event.pull_request.base.ref, 'release/')
        steps:
            - name: ðŸ“¥ Download release artifacts
              uses: actions/download-artifact@v4
              with:
                  pattern: release-artifacts-*
                  path: ./artifacts
                  merge-multiple: true

            - name: ðŸ—ï¸ Setup SSH key
              run: |
                  mkdir -p ~/.ssh
                  echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
                  chmod 600 ~/.ssh/id_rsa
                  ssh-keyscan -H ${{ vars.VPS_IP }} >> ~/.ssh/known_hosts
              shell: bash

            - name: ðŸ“¦ Copy .deb to VPS
              run: |
                  VERSION="${{ github.event.pull_request.base.ref }}"
                  VERSION_CLEANED="${VERSION#release/}"
                  scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ./artifacts/TEV_${VERSION_CLEANED}.deb ${{ vars.VPS_USER }}@${{ vars.VPS_IP }}:/home/student/TEV/TEV_${VERSION_CLEANED}.deb
              shell: bash

            - name: ðŸ› ï¸ Install .deb and restart service on VPS
              run: |
                  VERSION="${{ github.event.pull_request.base.ref }}"
                  VERSION_CLEANED="${VERSION#release/}"
                  ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no ${{ vars.VPS_USER }}@${{ vars.VPS_IP }} "cd /home/student/TEV && sudo dpkg -i TEV_${VERSION_CLEANED}.deb && sudo systemctl restart simeis.service.tev"
              shell: bash

            - name: ðŸ§ª Test /version endpoint
              run: |
                  VERSION="${{ github.event.pull_request.base.ref }}"
                  VERSION_CLEANED="${VERSION#release/}"
                  set -e
                  # Test HTTP connectivity and version
                  RESPONSE=$(curl -s --max-time 10 http://${{ vars.VPS_IP }}:6667/version || true)
                  echo "Response: $RESPONSE"
                  if [ -z "$RESPONSE" ]; then
                    echo "âŒ No response from server" >&2
                    exit 1
                  fi
                  if ! echo "$RESPONSE" | grep -q "$VERSION_CLEANED"; then
                    echo "âŒ Version mismatch: expected $VERSION_CLEANED, got $RESPONSE" >&2
                    exit 1
                  fi
                  echo "âœ… Version OK: $RESPONSE"
              shell: bash
